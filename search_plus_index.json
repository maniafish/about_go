{"./":{"url":"./","title":"Introduction","keywords":"","body":"2018 GopherChina 大会及培训分享 About GopherChina About Go Go Tools "},"intro.html":{"url":"intro.html","title":"About Go","keywords":"","body":"About Go(ultimate go) Introduction semantics, guidelines, mechanical sympathy and data oriented design in Go Catalog I. Go的性能指标 II. Go的堆栈分配 III. Go的垃圾回收 IV. Go的协程 V. Go的调试信息 VI. Go的interface VII. Go的变量作用域 VIII. Go的slice 声明 "},"performance.html":{"url":"performance.html","title":"I. Go的性能指标","keywords":"","body":"Go的性能指标 指标 latency cost 影响Go性能指标的几个因素 algorithm gc mechanical sympathy "},"heap_stack.html":{"url":"heap_stack.html","title":"II. Go的堆栈分配","keywords":"","body":"Go的堆栈分配 Golang的程序栈 每个goroutine维护着一个栈空间，默认最大为4KB 当goroutine的栈空间不足时，golang会调用runtime.morestack(汇编实现：asm_xxx.s)来进行动态扩容 连续栈：当栈空间不足的时候申请一个2倍于当前大小的新栈，并把所有数据拷贝到新栈， 接下来的所有调用执行都发生在新栈上。 每个function维护着各自的栈帧(stack frame)，当function退出时会释放栈帧 参考链接： go语言连续栈 为何说Goroutine的栈空间可以无限大 Goroutine stack function内部的栈操作 用一段简单的代码来说明Go函数调用及传参时的栈操作： package main func g(p int) int { return p+1; } func main() { c := g(4) + 1 _ = c } 执行go tool compile -S main.go生成汇编，并截取其中的一部分来说明一下程序调用时的栈操作 \"\".g t=1 size=17 args=0x10 locals=0x0 // 初始化函数的栈地址 // 0-16表示函数初始地址为0，数据大小为16字节(input: 8字节，output: 8字节) // SB是函数寄存器 0x0000 00000 (test_stack.go:3) TEXT \"\".g(SB), $0-16 // 函数的gc收集提示。提示0和1是用于局部函数调用参数，需要进行回收 0x0000 00000 (test_stack.go:3) FUNCDATA $0, gclocals·aef1f7ba6e2630c93a51843d99f5a28a(SB) 0x0000 00000 (test_stack.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) // FP(frame point)指向栈底 // 将FP+8位置的数据(参数p)放入寄存器AX 0x0000 00000 (test_stack.go:4) MOVQ \"\".p+8(FP), AX 0x0005 00005 (test_stack.go:4) MOVQ (AX), AX // 寄存器值自增 0x0008 00008 (test_stack.go:4) INCQ AX // 从寄存器中取出值，放入FP+16位置(返回值) 0x000b 00011 (test_stack.go:4) MOVQ AX, \"\".~r1+16(FP) // 返回，返回后程序栈的空间会被回收 0x0010 00016 (test_stack.go:4) RET 0x0000 48 8b 44 24 08 48 8b 00 48 ff c0 48 89 44 24 10 H.D$.H..H..H.D$. 0x0010 c3 . \"\".main t=1 size=32 args=0x0 locals=0x10 0x0000 00000 (test_stack.go:7) TEXT \"\".main(SB), $16-0 0x0000 00000 (test_stack.go:7) SUBQ $16, SP 0x0004 00004 (test_stack.go:7) MOVQ BP, 8(SP) 0x0009 00009 (test_stack.go:7) LEAQ 8(SP), BP 0x000e 00014 (test_stack.go:7) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x000e 00014 (test_stack.go:7) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) // SP(stack point)指向栈顶 // 把4存入SP的位置 0x000e 00014 (test_stack.go:8) MOVQ $4, \"\".c(SP) // 这里会看到没有第9行`call g()`的调用出现，这是因为go汇编编译器会把一些短函数变成内嵌函数，减少函数调用 0x0016 00022 (test_stack.go:10) MOVQ 8(SP), BP 0x001b 00027 (test_stack.go:10) ADDQ $16, SP 0x001f 00031 (test_stack.go:10) RET 事实上，即便我定义了指针调用，以上的数据也都是在栈上拷贝的；那么Golang中的数据什么时候会被分配到堆上呢？ 参考链接： Golang汇编快速指南 Golang汇编 Golang汇编命令解读 Golang逃逸分析 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，用于分析在程序的哪些地方可以访问到指针。 Golang在编译时的逃逸分析可以减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。 如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行，提高效率。 举个栗子 还是1.1里的那段程序代码，我们可以执行go build -gcflags '-m -l' test_stack.go来进行逃逸分析，输出结果如下 # command-line-arguments ./test_stack.go:3: g p does not escape ./test_stack.go:9: main &c does not escape 可以看到，对象c是没有逃逸的，还是分配在栈上。 即便在一开始定义的时候直接把c定义为指针： package main func g(p *int) int { return *p + 1 } func main() { c := new(int) (*c) = 4 _ = g(c) } 逃逸分析的结果仍然不会改变 # command-line-arguments ./test_stack.go:3: g p does not escape ./test_stack.go:8: main new(int) does not escape 那么，什么时候指针对象才会逃逸呢？ 按值传递和按址传递 按值传递 package main func g(p int) int { ret := p + 1 return ret } func main() { c := 4 _ = g(c) } 返回值ret是按值传递的，执行的是栈拷贝，不存在逃逸 按址传递 package main func g(p *int) *int { ret := *p + 1 return &ret } func main() { c := new(int) *c = 4 _ = g(c) } 返回值&ret是按址传递，传递的是指针对象，发生了逃逸，将对象存放在堆上以便外部调用 # command-line-arguments ./test_stack.go:5:9: &ret escapes to heap ./test_stack.go:4:14: moved to heap: ret ./test_stack.go:3:17: g p does not escape ./test_stack.go:9:10: main new(int) does not escape golang只有在function内的对象可能被外部访问时，才会把该对象分配在堆上 在g()方法中，ret对象的引用被返回到了方法外，因此会发生逃逸；而p对象只在g()内被引用，不会发生逃逸 在main()方法中，c对象虽然被g()方法引用了，但是由于引用的对象c没有在g()方法中发生逃逸，因此对象c的生命周期还是在main()中的，不会发生逃逸 再看一个栗子 package main type Ret struct { Data *int } func g(p *int) *Ret { var ret Ret ret.Data = p return &ret } func main() { c := new(int) *c = 4 _ = g(c) } 逃逸分析结果 # command-line-arguments ./test_stack.go:10:9: &ret escapes to heap ./test_stack.go:8:6: moved to heap: ret ./test_stack.go:7:17: leaking param: p to result ~r1 level=-1 ./test_stack.go:14:10: new(int) escapes to heap 可以看到，ret和2.2中一样，存在外部引用，发生了逃逸 由于ret.Data是一个指针对象，p赋值给ret.Data后，也伴随p发生了逃逸 main()中的对象c，由于作为参数p传入g()后发生了逃逸，因此c也发生了逃逸 当然，如果定义ret.Data为int(instead of *int)的话，对象p也是不会逃逸的(执行了拷贝) 参考链接： Go语言逃逸分析 对开发者的一些建议 大对象按址传递，小对象按值传递 按址传递更高效，按值传递更安全(from William Kennedy) 90%的bug都来自于指针调用 初始化一个结构体，使用引用的方式来传递指针 func r() *Ret{ var ret Ret ret.Data = ... ... return &ret } 只有返回ret对象的引用时才会把对象分配在堆上，我们不必要在一开始的时候就显式地把ret定义为指针 ret = &Ret{} ... return ret 对阅读代码也容易产生误导 "},"gc.html":{"url":"gc.html","title":"III. Go的垃圾回收","keywords":"","body":"Go的垃圾回收 GC算法 go1.5以前使用标记清除法(Mark-Sweep)： 从程序根节点开始递归遍历所有对象，将能遍历到的对象打上标记 将所有未标记的的对象当作垃圾销毁 不用担心循环引用问题，但是需要一段时间来暂停程序以便标记 go1.5后采用的是三色标记算法(white-grey-black)： 打开write barrier(写屏障) write barrier是编译器在每个内存写操作前生成的一个小的代码段，用于在golang gc时监控指针的引用操作，防止误回收。 将所有escape to heap的对象放入白色集合中 遍历程序栈，将遍历到白色集合中的对象放入灰色集合中 遍历灰色集合中的对象，将遍历到的灰色对象放到黑色集合中，并将此灰色对象引用到的白色对象放入灰色集合中 重复4，直到灰色集合中没有对象。在此过程中，若write barrier检测到有黑色对象引用了白色对象，会将此白色对象放入灰色集合中 回收掉白色集合中的对象 STW(Stop the World) golang在进行GC的时候是需要一小段时间来暂停程序的运行的。golang每升级一个大版本，都会对GC做一定的优化，以提升GC效率、缩短STW的时间： go1.4前使用标记清除法，在每次GC标记内存对象时都需要一段STW时间(毫秒到秒级) go1.4并行处理标记和清理协程，但是仍然需要在标记时STW go1.5-1.7使用三色标记算法，只在write barrier和rescan grey stacks时STW(毫秒级) go1.8使用hybrid write barrier，去除了rescan grey stacks的STW，STW时间在10-100微秒 go1.9后提升了对大对象的收集效率，STW时间基本稳定在100微秒内 参考链接： gotraining/pointers/gc golang垃圾回收机制 Golang 垃圾回收剖析 知乎: write barrier 为Go语言GC正名－2秒到1毫秒的演变史 go 1.8 eliminate stw stack re-scanning 减轻GC压力 golang gc的时间长短，主要和待GC的对象数量有关，待GC的对象越少，GC的时间越短。 sync.Pool 临时对象池，用于复用已产生的对象，减少程序内对象的数量，减轻GC压力。sync.Pool是并发安全的。 参考链接： sync.Pool "},"goroutine.html":{"url":"goroutine.html","title":"IV. Go的协程","keywords":"","body":"Go的协程 Go协程和线程的区别 资源调度 线程由内核调度，根据cpu时间片执行抢占式调度 协程由程序调度(runtime包)，执行协同式调度(2中会详述) 内存占用 执行线程所需的栈内存至少是MB级别 执行协程只需要4KB左右的栈内存 上下文切换 线程涉及到用户态和内核态的切换：需要切换通用寄存器(8个)，程序计数器PC，指令寄存器IR，地址寄存器AR，累加寄存器AC，状态寄存器EFLAGS等 协程上下文切换只涉及到栈指针和三个寄存器(程序计数器PC, 栈指针寄存器SP, 数据寄存器DX）的切换 参考链接： Golang协程详解 通用寄存器 Go协程调度 M：内核线程 G：goroutine，并发的最小逻辑单元，由程序创建 P：处理器，执行G的上下文环境，每个P会维护一个本地的goroutine队列 goroutine有三个状态： waiting: 协程处于全局的队列等待调度 runnable: 协程处于本地队列，等待执行 running: 协程正在运行 G的创建 go调用runtime.newproc()方法来创建G 首先，检查当前P的空闲队列中有没有可用的G，如果有，就直接从中取一个；如果没有，则分配一个新的G，挂载到P的本地队列中 获取了G之后，将调用参数保存到G的栈中，将SP, PC等上下文环境保存到G的sched域中 此时的G处于runnable状态，一旦分配到CPU，就可以进入running状态 G何时被调度 当G被创建时，会立即获得一次运行的机会 如果此时正在运行的P的数量没有达到上限，go会调用runtime.wakep()方法唤醒P；然后调度器选择M绑定P来执行G，必要时会新建M 当此时正在运行的P数量到达上限时，G会进入本地队列等待，当队列前面的G处于以下几种状态时，会触发切换，进入waiting状态： 加锁 io操作 系统调用 运行时间过长(runnable) G的消亡 当G执行完毕返回后，go会调用runtime.exit()方法回收G(包括回收栈指针, 清空寄存器SP、 PC...) 然后将G放入P的空闲队列中，等待runtime.newproc()方法取出 参考链接： golang之协程 goroutine的生老病死 谈goroutine调度器 Go channel channel是go协程通信的主要方式。channel不是队列，可以把它理解为一种信号模型(from William Kennedy) channel分为以下两种类型： 一种是无缓冲的channel，在创建channel时不指定长度。无缓冲的channel若没有用户读取，在写入时会始终阻塞，通常可以作为保证信号使用 另一种是缓冲的channel，即buffer channel，在创建channel时指定长度(>=1)。buffer channel为空时会阻塞读，buffer channel满时会阻塞写，可以作为数据传输使用 当buffer channel的长度指定为1时，可以作为延迟保证信号使用(信号发送方发送信号后不阻塞等待接收方接收) channel有以下三种状态： nil：初始化channel。无法读写 open：通过make分配channel空间。可读可写 close: 通过close()关闭channel。close的channel != nil；可以继续从中读取数据，但是不能写入(panic) 参考链接： gotraining/concurrency/channels 基于channel实现的异步日志模型 package main import ( \"fmt\" \"io\" \"os\" \"strconv\" \"sync\" ) var globalWg sync.WaitGroup // Logger struct implement log type Logger struct { channel chan string wg sync.WaitGroup } // NewLog return a new Logger func NewLog(w io.Writer, cap int) *Logger { l := Logger{ channel: make(chan string, cap), } l.wg.Add(1) go func() { defer l.wg.Done() for v := range l.channel { fmt.Fprintln(w, v) } fmt.Println(\"close\") }() return &l } // Close close logger func (l *Logger) Close() { close(l.channel) l.wg.Wait() } // Println print msg func (l *Logger) Println(v string) { select { case l.channel 执行结果： output: 11 0 5 1 2 3 4 8 6 7 9 10 close 可以看到，超过并发数的时候执行了default行为输出了output: 11 当然，我们也可以自定义default行为，比如超过并发数的时候停等一小段时间再写入；或者是不设置default行为，超过并发时阻塞写入直到解除阻塞为止。 这个模型还可以结合协程池grpool，来做一个后台并发写入的日志系统 效率和安全始终是一对矛盾，异步日志虽然能很大程度提高程序效率(不需要等待io操作)；但是如果程序crash，在channel中尚未写入的数据就会丢失。因此在使用的时候也要注意channel的长度设置，如果需要guarantee的，甚至要设置成unbuffer(基本等于同步日志)或者buffer = 1。 Suggestion 单核过多线程未必会提高效率，更多的抢占式调度和上下文切换，有时反而会让效率降低；经验之谈：3 thread per core is best(from William Kennedy) 对于cpu-bound work，高并发未必会提高效率(cpu密集型工作的切换还是需要cpu来调度) 对于io-bound work，应该最大限度地利用并发来提高效率 "},"stack_trace.html":{"url":"stack_trace.html","title":"V. Go的调试信息","keywords":"","body":"Go的调试信息 当golang程序出现panic的时候会输出一段堆栈调试信息，开发人员可以通过这些调试信息快速地定位问题。 举个栗子 我们通过下面这段程序，直接让程序panic package main func main() { slice := make([]string, 2, 4) Example(slice, \"hello\", 10) } func Example(slice []string, str string, i int) { panic(\"stack trace\") } 运行后输出的调试信息如下 panic: stack trace goroutine 1 [running]: main.Example(0xc42003ff30, 0x2, 0x4, 0x106b75a, 0x5, 0xa) /Users/maniafish/Myworkspace/go_project/src/test/test_panic.go:9 +0x39 main.main() /Users/maniafish/Myworkspace/go_project/src/test/test_panic.go:5 +0x76 exit status 2 第一行是panic信息: stack trace 第二行是发生panic的goroutine及其运行状态(running) 接下来就是发生panic的function调用情况了。我们通常会关注显示的文件和行号，可以快速定位到是哪一行代码抛出的异常 除此之外我们还可以从中看到发生panic的function的输入参数，如main.Example(0xc42003ff30, 0x2, 0x4, 0x106b75a, 0x5, 0xa)对应func Example(slice []string, str string, i int)的三个输入参数： slice: 0xc42003ff30(slice指针地址), 0x2(slice的长度), 0x4(slice的容量) str: 0x106b75a(str字符串头指针地址), 0x5(str字符串长度) i: 0xa(i = 10) 空指针错误 package main import \"fmt\" type S struct { Msg string } func (s *S) f(a int) { fmt.Printf(\"%v: %d\\n\", s.Msg, a) } func main() { Example(nil) } func Example(s *S) { s.f(1) } 以上这段程序运行结果如下： panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x1095257] goroutine 1 [running]: main.(*S).f(0x0, 0x1) /Users/maniafish/Myworkspace/go_project/src/test/test_panic.go:10 +0x57 main.Example(0x0) /Users/maniafish/Myworkspace/go_project/src/test/test_panic.go:18 +0x34 main.main() /Users/maniafish/Myworkspace/go_project/src/test/test_panic.go:14 +0x2a exit status 2 panic信息(invalid memory address or nil pointer dereference)告诉我们是无效的地址调用 我们通过main.(*S).f(0x0, 0x1)的第一个参数，可以知道这个指针*S的方法f()调用时使用的是空指针 然后通过main.Example(0x0)，知道这个空指针是通过Example()方法传进来的，定位到了问题所在。 参考链接： Go stack trace "},"composition.html":{"url":"composition.html","title":"VI. Go的interface","keywords":"","body":"Go的interface go的interface类型定义了一组方法，如果某个对象实现了某个interface的所有方法，此对象就实现了此interface。 interface focus on what the data does, instead of what the data is(From William Kennedy) interface能够帮助我们更好地做泛型编程，实现代码逻辑的抽象和灵活组合，更方便地进行面向对象的编程。 下面通过一个例子来说明一下go中基于interface的编程设计思路。 场景1 设计思路 定义结构体A，实现方法Store() 定义结构体B，实现方法Pull() 定义System封装A和B，并通过System向外提供api 代码示例 // A is a system for data collection type A struct { ... } // Store function for storing data func (a *A) Store(data interface{}) { ... } // B is a system for data pulling type B struct { ... } // Pull function for pulling data func (b *B) Pull(data interface{}) { ... } // System wraps A and B together type System struct { A B } // Api providing api for users func Api(s *System, data []interface{}) error { ... for _, v := range data { s.Store(v) } ... dp := ... err = s.Pull(dp) ... return } func main() { a := A { ... } b := B { ... } s := System{a, b} data := ... err := Api(&s, data) if err != nil { ... } ... } 场景2 设计思路 系统组件A1~A3都实现了同样的方法Store()，B1~B3实现了Pull()，考虑使用interface进行抽象解耦 system无需关心具体的A和B，只需要做interface的组合即可 代码示例 // Storer is an interface for data collection type Storer interface { Store(data interface{}) } // A1 is a system for data collection type A1 struct { ... } // Store function for storing data func (a *A1) Store(data interface{}) { ... } // define A2 ~ A3 implementing Storer ... // Puller is an interface for data pulling type Puller interface { Pull(data interface{}) } // B1 is a system for data pulling type B1 struct { ... } // Pull function for pulling data func (b *B1) Pull(data interface{}) { ... } // define B2 ~ B3 implementing Puller ... // System wraps Storer and Puller together type System struct { Storer Puller } // Api providing api for users func Api(s *System, data []interface{}) error { ... for _, v := range data { s.Store(v) } ... dp := ... err = s.Pull(dp) ... return } func main() { ... a := A1 { ... } b := B1 { ... } // s can be any composition of An and Bn s := System{&a, &b} data := ... err := Api(&s, data) if err != nil { ... } ... } 进一步抽象 我们希望Api()方法变得更加通用，它无需关心System的具体结构，只关心System提供的Pull()和Store()方法 因此我们可以定义一个PullStorer来做Puller和Storer的interface组合，这样一来只要是实现了Puller和Storer的结构体，都可以由Api()方法调用来对外提供服务 ... // PullStorer is an interface implementing Storer and Puller type PullStorer interface { Storer Puller } // Api providing api for users func Api(s PullStorer, data []interface{}) error { ... for _, v := range data { s.Store(v) } ... dp := ... err = s.Pull(dp) ... return } func main() { ... // s can be any composition of An and Bn s := System{ ... } data := ... err := Api(&s, data) if err != nil { ... } ... } interface滥用问题 我们现在定义了以下interface // Storer is an interface for data collection type Storer interface { Store(data interface{}) } // Puller is an interface for data pulling type Puller interface { Pull(data interface{}) } // PullStorer is an interface implementing Storer and Puller type PullStorer interface { Storer Puller } 我们的Api()里关注的是Store()和Pull()方法 // Api providing api for users func Api(s PullStorer, data []interface{}) error { ... for _, v := range data { s.Store(v) } ... dp := ... err = s.Pull(dp) ... return } 这个传入Api()的s，可以是任意实现了Store()方法的An和任意实现了Pull()方法的Bn的组合 我们在Api()中调用s.Store()，实际上调用的是s.Storer.Store()；调用s.Pull()，实际上调用的是s.Puller.Pull() 既然我们的Api()关注的只是Puller和Storer，那么我们为什么要额外让他们组合成一个PullStorer来传入呢 基于以上设计思路，我们可以去掉System和PullStorer，得到以下简洁且可扩展性强的代码 // Storer is an interface for data collection type Storer interface { Store(data interface{}) } // A1 is a system for data collection type A1 struct { ... } // Store function for storing data func (a *A1) Store(data interface{}) { ... } // define A2 ~ A3 implementing Storer ... // Puller is an interface for data pulling type Puller interface { Pull(data interface{}) } // B1 is a system for data pulling type B1 struct { ... } // Pull function for pulling data func (b *B1) Pull(data interface{}) { ... } // define B2 ~ B3 implementing Puller ... // Api providing api for users func Api(s Storer, p Puller, data []interface{}) error { ... for _, v := range data { s.Store(v) } ... dp := ... err = p.Pull(dp) ... return } func main() { ... a := A1 { ... } b := B1 { ... } // a can be any An, b can be any Bn data := ... err := Api(&a, &b, data) if err != nil { ... } ... } "},"operator.html":{"url":"operator.html","title":"VII. Go的变量作用域","keywords":"","body":"Go的变量作用域 变量作用域 全局变量 package a var g int // 本包内可见 var G int // 外部import a后可见 局部变量 func Test() { var a int // a在Test()内可见 ... for i := 1; i 参数变量 func Test(a int) { // a在Test()方法内可见，在Test()外赋值。 ... } 局部变量声明后未使用会编译失败；参数变量在function内可以不使用，比如以下情况也是可以编译通过的。 func main() { a := 1 Test(a) // a作为参数调用 } func Test(a) { // a在Test()内部没有使用 fmt.Println(\"test\") } 对按值传参的情况，方法内对参数a的修改不影响传入前的原参数a 对按址传参的情况，方法内对参数a的修改也会影响到传入前的原参数a 循环并发中的变量传参问题 理解了go中的变量作用域后，我们来看看下面这段代码 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func main() { for i := 0; i 输出结果如下 10 10 10 10 10 10 10 10 10 10 这是因为变量i作为局部变量，同时在for循环和go协程中被引用，循环递增和打印的是同一个地址的数据 实际上这个输出是无法预期的，这里都输出10是因为后台协程完成创建时，for循环已经完成了对i的递增操作 如果要想让循环中的go协程如我们预期的一样输出1~10的值，要采取以下写法，使用参数变量 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func main() { for i := 0; i Go的:=操作符 Go的:=操作符用于声明变量的同时给变量赋值，它也会定义新变量的作用域。以下面这段代码为例 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func main() { a := 1 fmt.Printf(\"a in main: %p, %d\\n\", &a, a) // a in main: 0xc420016090, 1 // 在main中声明了变量a，地址为0xc420016090，并给a赋值为1 for a := 2; a "},"slice.html":{"url":"slice.html","title":"VIII. Go的slice","keywords":"","body":"Go的slice go的slice可以理解为一种动态可变长的数组，初始化时可以指定长度len和容量cap；可以通过append()方法在slice末尾追加元素。 一个append的栗子 package main import \"fmt\" func main() { s0 := []int{1, 2, 3, 4} fmt.Printf(\"s0: %v, len(s): %d, cap(s): %d\\n\\n\", s0, len(s0), cap(s0)) // s0: [1 2 3 4], len(s): 4, cap(s): 4 // 初始化一个slice s0，len = cap = 4(不指定cap的情况下，默认cap = len) s1 := s0[:2] fmt.Printf(\"s1: %v, len(s1): %d, cap(s1): %d\\n\\n\", s1, len(s1), cap(s1)) // s1: [1 2], len(s1): 2, cap(s1): 4 // 取s0的前个元素构成s1，len = 2, cap = 4 s2 := append(s1, 5, 6, 7) fmt.Printf(\"s2: %v, len(s2): %d, cap(s2): %d\\n\", s2, len(s2), cap(s2)) fmt.Printf(\"s0: %v, len(s0): %d, cap(s0): %d\\n\\n\", s0, len(s0), cap(s0)) // s2: [1 2 5 6 7], len(s2): 5, cap(s2): 8 // append 5, 6, 7到s1，此时空间不足，按照两倍cap动态扩容，分配一块新的内存空间给s2 // s0: [1 2 3 4], len(s0): 4, cap(s0): 4 // s0不变 s3 := append(s1, 8, 9) fmt.Printf(\"s3: %v, len(s3): %d, cap(s3): %d\\n\", s3, len(s3), cap(s3)) fmt.Printf(\"s0: %v, len(s0): %d, cap(s0): %d\\n\\n\", s0, len(s0), cap(s0)) // s3: [1 2 8 9], len(s3): 4, cap(s3): 4 // append 8, 9到s1，空间足够，无须扩容 // s0: [1 2 8 9], len(s0): 4, cap(s0): 4 // s0的后两个元素被append的8, 9取代 } 通过以上栗子可以看出： go的slice只有在空间不足时，才会进行动态扩容，分配新的内存地址。所以在日常开发的时候，要尽量避免以下操作： func A(i []int){ ... b := append(i, ...) ... } func main(){ ... a := []int{...} A(a[:2]) ... } 要防止slice b的操作影响到slice a，可以使用copy()方法 func A(i []int){ ... b := append(i, ...) ... } func main(){ ... a := []int{...} i := make([]int, 2) copy(i, a[:2]) A(i) ... } go的slice执行的动态扩容是一个内存拷贝的操作，分配一块新的2倍cap的空间给slice。因此在平时开发的时候，应该尽可能地分配确定的len和cap给slice，防止频繁append进行内存拷贝带来的性能损耗。 比如以下这段代码 func main() { a := make([]int, 0) for i := 0; i 可以改写成下面这样，使用确定的len func main() { a := make([]int, 10) for i := 0; i 即便在不确定len的情况下，也应该尽量预留一个相对充足的cap，来减少2倍cap扩容的次数 func main() { a := make([]int, 0, 10) for i := 0; i 默认按地址传递 通过1.1中的栗子 func A(i []int){ ... b := append(i, ...) // 操作b的时候也会影响到a ... } func main(){ ... a := []int{...} A(a[:2]) ... } 就可以知道，go中slice传参默认是按址传递的，因此在function内对传入的slice进行写操作的时候要注意：这种操作是会影响到function调用方的原slice的。go的map也是默认按址传递 "},"notice.html":{"url":"notice.html","title":"声明","keywords":"","body":"声明 本gitbook内容来源如下: GopherChina 2018会前培训及会议 arbanlabs/gotraining 各章节参考链接中注明的网络资料 日常开发经验 如有任何问题或建议，欢迎来maniafish/about_go项目下提出您宝贵的issue "}}